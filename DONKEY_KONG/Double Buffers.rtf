{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f36\fswiss\fcharset0\fprq2{\*\panose 020b0a04020102020204}Arial Black;}{\f149\froman\fcharset238\fprq2 Times New Roman CE;}{\f150\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f152\froman\fcharset161\fprq2 Times New Roman Greek;}{\f153\froman\fcharset162\fprq2 Times New Roman Tur;}{\f154\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f155\froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f156\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f157\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f159\fswiss\fcharset238\fprq2 Arial CE;}{\f160\fswiss\fcharset204\fprq2 Arial Cyr;}{\f162\fswiss\fcharset161\fprq2 Arial Greek;}
{\f163\fswiss\fcharset162\fprq2 Arial Tur;}{\f164\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f165\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f166\fswiss\fcharset186\fprq2 Arial Baltic;}{\f167\fswiss\fcharset163\fprq2 Arial (Vietnamese);}
{\f169\fmodern\fcharset238\fprq1 Courier New CE;}{\f170\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f172\fmodern\fcharset161\fprq1 Courier New Greek;}{\f173\fmodern\fcharset162\fprq1 Courier New Tur;}
{\f174\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f175\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f176\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f177\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}
{\f509\fswiss\fcharset238\fprq2 Arial Black CE;}{\f510\fswiss\fcharset204\fprq2 Arial Black Cyr;}{\f512\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f513\fswiss\fcharset162\fprq2 Arial Black Tur;}{\f516\fswiss\fcharset186\fprq2 Arial Black Baltic;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}{\*\rsidtbl \rsid12203606}{\*\generator Microsoft Word 10.0.6829;}{\info
{\operator t}{\creatim\yr2007\mo5\dy18\hr7\min49}{\revtim\yr2007\mo5\dy18\hr7\min51}{\version2}{\edmins2}{\nofpages2}{\nofwords1030}{\nofchars5872}{\nofcharsws6889}{\vern16393}{\*\password 00000000}}{\*\xmlnstbl }
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\gutter0 \widowctrl\ftnbj\aenddoc\grfdocevents0\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3
\jcompress\viewkind4\viewscale100\nolnhtadjtbl\rsidroot12203606 \fet0{\*\wgrffmtfilter 013f}\sectd \linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}
{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}
{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain 
\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f36\fs36\insrsid12203606 DOUBLE BUFFERS IN TURBO C++
\par }{\f36\fs20\insrsid12203606 George Eleftheriou
\par 
\par }{\f1\fs20\insrsid12203606 \tab Obviously you have picked this up because you want your game doesn't look good. Thankfully, (probably unknown to you) you have the tools to fix that! The following w
ill bring you up to speed on double buffers, how they work, and how to implement them into your game. 
\par 
\par }{\b\f1\fs20\insrsid12203606 What is a double buffer?
\par }{\f1\fs20\insrsid12203606 \tab 
\par \tab A double buffer, although it may sound kind of complicated, is actually pretty simple. As you probably already know, when yo
u want to animate something you have to constantly refresh the screen (that means clearing it). Or, you may store your image in memory and use some of the graphics commands (XOR_PUT, AND_PUT) to animate it. Well, double buffering simplifies and speeds thi
s
 process. As a matter of fact, every single game currently out uses a double buffer because they are so efficient. Anyways, a double buffer simply refers to a big segment of memory used to store the graphics screen in. When you are double buffering, you l
iterally "build" the screen in memory, then each frame you instantly put that memory to the screen. It's fast, efficient, and it means no flashing graphics. 
\par }{\b\f1\fs20\insrsid12203606 
\par Using a double buffer
\par 
\par }{\f1\fs20\insrsid12203606 \tab Now, although double buffering may sound somewhat simple in concept, it's 
actually a little tougher to implement. Think about it for a second. Every command you have learned will put something directly to the screen, not into some segment of memory. That means that any graphics command you have previously learned will not be co
mpatible with double buffering. That's not to say you can't use them, but I can't guarantee you will always get the desired results. 
\par \tab The first thing you need to do when using a double buffer is to create a }{\b\f1\fs20\insrsid12203606 pointer }{\f1\fs20\insrsid12203606 to the actual video screen (yes, it is also a }{\f1\fs20\insrsid12203606 piece}{\f1\fs20\insrsid12203606 
 of memory) and to the buffer. I'm not going to give you a lesson in pointers, you will need to consult someone else or the internet, but I will show you how to use them. Create both these }{\f1\fs20\insrsid12203606 variables}{\f1\fs20\insrsid12203606 
 like this:
\par 
\par \tab }{\f2\fs20\insrsid12203606 unsigned char far *Vidseg = (unsigned char far *)0}{\f2\fs20\insrsid12203606 xA0000000L; }{\f2\fs20\insrsid12203606 
\par \tab unsigned char far Virseg[64000];
\par 
\par }{\f1\fs20\insrsid12203606 \tab There you go. I used }{\f2\fs20\insrsid12203606 Vidseg}{\f1\fs20\insrsid12203606  (video segment) for the actual video }{\f1\fs20\insrsid12203606 memory}{\f1\fs20\insrsid12203606  and }{\f2\fs20\insrsid12203606 Virseg}{
\f1\fs20\insrsid12203606  (virtual segment) for the virtual video screen (the buffer). Feel free to change these as necessary. As you will notice, the buffer is si}{\f1\fs20\insrsid12203606 mply an array of }{\f2\fs20\insrsid12203606\charrsid12203606 
unsigned char far}{\f1\fs20\insrsid12203606 , 64000 to be exact. Each element of the array represents one pixel, so this resolution is 320 x 200. Unfortunately, that is about as high as you can get in Turbo C++. The pro
gram can only handle so much memory, and this is pushing the limit. So logically, if you can only get a 320 x 200 resolution in your buffer, you probably need to set your video screen to the same resolution. Well, you already know how to do this. In the b
itmap packet that you have probably read, a command is given to get 256 colors at a lower resolution. Here it is:
\par 
\par \tab }{\f2\fs20\insrsid12203606 graphinit(GR256);
\par 
\par }{\f1\fs20\insrsid12203606 \tab So now you may have a lower resolution (which you can't do anything about anyways), but you get 256 colors. Somewhat of a tradeoff. 
\par 
\par }{\b\f1\fs20\insrsid12203606 Using the DBUFFER.H library
\par 
\par }{\f1\fs20\insrsid12203606 \tab I have created a library called DBUFFER.H that contains some very useful commands for double buffering, so that you don't have to figure everything out. In the code there are some explanations of the functions, bu
t I will go ahead and explain them more in-depth here.
\par \tab The first command I want to explain is }{\b\f1\fs20\insrsid12203606 flip}{\f1\fs20\insrsid12203606 
. This is probably the most vital command in double buffering, because it takes the buffer and instantaneously puts it to the screen. Its parameters are (Sou
rce, Destination) with the source being the buffer, and the destination being the screen. Here is an example.
\par 
\par \tab }{\f2\fs20\insrsid12203606 flip(Virseg,Vidseg);
\par 
\par }{\f1\fs20\insrsid12203606 \tab The second command that is very vital to double buffering is the }{\b\f1\fs20\insrsid12203606 clearmem}{\f1\fs20\insrsid12203606 
 function. Guess what it does? Clears memory! Its parameters are (Source, Length of the array). What this command does is simply fill the array with color 255 (black). You will find this to be very useful. }{\b\f1\fs20\insrsid12203606 Note}{
\f1\fs20\insrsid12203606 : the Source parameter is of type }{\f2\fs20\insrsid12203606 unsigned char far}{\f1\fs20\insrsid12203606 . As a matter of fact, }{\b\f1\fs20\insrsid12203606 any}{\f1\fs20\insrsid12203606 
 segment of memory that you create (whether for bitmaps or backgrounds) needs to be of this type, and as a native array. As an example, look at the virtual memory defined previously. Also, don't try to clear the video screen 
with this. It doesn't work. Use }{\b\f1\fs20\insrsid12203606 cleardevice();}{\f1\fs20\insrsid12203606 , it works. 
\par \tab The }{\b\f1\fs20\insrsid12203606 loadbitmap}{\f1\fs20\insrsid12203606 
 command does exactly what it sounds like. Why can't you use the bitmap library? Because the bitmap library draws everything directly to the screen, and we want to draw it to memory!
 Starting to make sense? What it literally does is take a bitmap and store it into a segment of memory (which you define), which can be later put into the buffer, then displayed on the screen. Its parameters are (Filename, Transparency color, Destination)
.
 Now, I won't completely condone this command, because it doesn't work all the time. For starters, it only accepts 16 color (4-bit) bitmaps, and sometimes does not work. If you run into a lot of problems with this command, you could always make your own b
itmaps! Do this by just creating a file with numbers that reference colors (0-255), and read it into an array of unsigned char far. 
\par \tab Once you have taken your bitmaps and put them in arrays of }{\f2\fs20\insrsid12203606 unsigned char far}{\f1\fs20\insrsid12203606 , you need to put them into the buffer. I created the }{\b\f1\fs20\insrsid12203606 transfer}{\f1\fs20\insrsid12203606 
 command to do just that. When using this command, you need to know how big your array (or picture, if you prefer) is. Its parameters are (X, Y, X1, Y1, Source, Destination). If your picture is, say, 16 x 16, and you want to display it at (0
,0) you would want it to look like this:
\par 
\par \tab }{\f2\fs20\insrsid12203606 transfer(0,0,16,16,Bitmap,Virseg);
\par \tab 
\par \tab }{\f1\fs20\insrsid12203606 Bitmap refers to an array of }{\f2\fs20\insrsid12203606 unsigned char far}{\f1\fs20\insrsid12203606 
, most likely where a bitmap is stored. Simple enough, right? Remember, every segment of memory that you want to use as a "graphic" needs to be defined as an array of }{\f2\fs20\insrsid12203606 unsigned char far}{\f1\fs20\insrsid12203606 
, as this is the type that all these functions take. 
\par \tab Finally, the last command is }{\b\f1\fs20\insrsid12203606 cutbackground}{\f1\fs20\insrsid12203606 . This simply does the exact same thing as }{\b\f1\fs20\insrsid12203606 transfer}{\f1\fs20\insrsid12203606 
, just renamed. Why? Simply for organization. When an
imating, you obviously can't just start moving an image - you'll end up with a trail. What needs to be done is to take the section of background before you lay down an image, and replace it on the next frame. This is the }{\b\f1\fs20\insrsid12203606 only}
{\f1\fs20\insrsid12203606  way you can animate, but it is very simple to do. Just think about it for a second, and you'll get it. 
\par 
\par }{\b\f1\fs20\insrsid12203606 Implementing a double buffer
\par 
\par }{\f1\fs20\insrsid12203606 \tab You think I'm going to tell you how to write your program, don't you? Sorry! What I can give you, though, is the advice that the }{\b\f1\fs20\insrsid12203606 best}{\f1\fs20\insrsid12203606  way to be a succ
essful programmer is to think about what you're going to do before you do it. This can be in the form of mental thought or even better: pseudocode. Read this several times, look at examples, and you'll be well on your way to putting double buffers in your
 games. If you do have any questions, you can email me at }{\b\f1\fs20\insrsid12203606 coolgreek@gmail.com}{\f1\fs20\insrsid12203606  . Best of luck! 
\par 
\par \tab }{\b\f36\fs36\insrsid12203606 
\par }{\f1\fs20\insrsid12203606 
\par }}